# VLSI-NPTEL

Week 1 (lecture 1-Introduction to VLSI design)

![image](https://github.com/user-attachments/assets/6111cae5-3cad-40e6-8df1-039beab117e2)


![image](https://github.com/user-attachments/assets/63c21c0a-ace4-4d8a-bb52-4159a8ee8b95)


![image](https://github.com/user-attachments/assets/ee2b0dee-cda4-426a-baa3-5c264f368700)


![image](https://github.com/user-attachments/assets/6056f384-15bc-4ec8-a7c1-50055eb1cbcb)


![image](https://github.com/user-attachments/assets/1bfd35df-e87c-46f0-a457-9cba387f1e8d)

Time to market is the driving force to make the chip. If the chip has to be manufactured within the small amount of time, then semi-custom design is the best thing to do.

![image](https://github.com/user-attachments/assets/2b14e9cb-533d-42eb-8bb6-ed174753fed1)

Semi-custom design are the designs that are designed and manufactured by the third-party companies and sold.

![image](https://github.com/user-attachments/assets/563ee186-d19a-49ac-bfe3-7d07a8c4802c)

![image](https://github.com/user-attachments/assets/c79abe8a-cb33-4d83-a807-cbcf8b83ad5a)

![image](https://github.com/user-attachments/assets/aa3b730a-11d2-4ab7-804d-ee9c547d84e7)

The heights of the standard cells are same or multiples of each other. The heiights depends on the number of metals on track. The width of the cells are the multiple of unit tile which is present in the technology file. The characterized library provides library files, timing files and power characterization.

![image](https://github.com/user-attachments/assets/c20316e8-c1b6-4788-9061-7251eaddc531)

![image](https://github.com/user-attachments/assets/e1af8a77-9bbc-4503-bc9b-2c91c6490ce1)

The channel is prsent as shown in the diagram below. The channel is used for the routing the metals tracks. There is also a thing called feed through cells which are used to route through another channels when the number of layers of the chip is minimum.

![image](https://github.com/user-attachments/assets/ac5da6ff-bc83-4ba0-a89b-a558c2fb1f6a)

Standard cell design is faster than the full custom design flow and it is more popular.

![image](https://github.com/user-attachments/assets/c8004938-7522-4174-88cf-f624833d466c)

![image](https://github.com/user-attachments/assets/4575486a-d946-40b9-82ea-e335d6c73e76)

![image](https://github.com/user-attachments/assets/3bcc1253-59bd-4b8d-9caf-a023270fa2b6)

Macro cells can be placed anywhere in the layout, but it should be placed in such a way that the delay will be reduced.

![image](https://github.com/user-attachments/assets/87250030-6602-4c8e-b3c2-5aac0fdd89a7)

The identical cells are repeated throughout the chip in the matrix form in Array-Based design style.

![image](https://github.com/user-attachments/assets/a5c53e88-9cf5-44c2-b374-5746e8c73855)

In uncommitted gate array, the routing layers are on the top. It is expensive because, we need to get a gate array and do the required things. In committed gate array, the routing layers will be present and we need to do programming to connect them according to our need.

![image](https://github.com/user-attachments/assets/a472dfd5-46b1-4e13-87ed-7307a1de694f)

Here, we map the actual design with it and do the routing.

![image](https://github.com/user-attachments/assets/e7cd7f95-53dc-4f8c-920f-ab5c16606396)

In committed gate array, the example is shown below where there are 5 NAND gates and we route them and use it.

![image](https://github.com/user-attachments/assets/e670d291-8caa-4563-a96c-a910bac532c6)

![image](https://github.com/user-attachments/assets/2abb7281-9ed6-45d2-8932-2f94dbec4490)

In the case of FPGA we have programmable IO, interconnect and LUT.

![image](https://github.com/user-attachments/assets/2eab94db-abd3-43ac-86a8-f8b0497adf1e)

Switch box are the interconnects that are programmable in the runtime. We can implement both combinational and sequential logics using this.

![image](https://github.com/user-attachments/assets/a9e3ccd4-583f-4d96-a012-c6d80a04e3f9)

Here, the gate level circuit is mapped to the LUT.

![image](https://github.com/user-attachments/assets/114793bf-27c3-4372-8e30-d30dc7187928)

Modules are the different blocks inside the system(chip) and how they are connected to each other. If we go into one of the module,
gates are there which is called gate level. Inside that we have transistor level. Then we have device which is implemented using silicon.
We need to do optimization in all the levels to achive the three targets mentioned in the diagram below.

![image](https://github.com/user-attachments/assets/a5266c61-2287-43c7-8b6b-59a4a8acb3a3)

![image](https://github.com/user-attachments/assets/5756e19d-2223-429a-be2b-9899cfc2d1f0)

![image](https://github.com/user-attachments/assets/615bf9f0-5b44-4419-93b1-e1ced711c33b)

![image](https://github.com/user-attachments/assets/8a341196-b554-491e-903d-c4478ffeeca1)

![image](https://github.com/user-attachments/assets/ca25f5ed-10ef-462c-8f22-802da0339409)

![image](https://github.com/user-attachments/assets/42d50d7b-efc3-474c-9d47-6404590ae324)

![image](https://github.com/user-attachments/assets/e4a45e85-5909-4115-ba9b-4041821791ae)

![image](https://github.com/user-attachments/assets/9dd8b32d-1c44-4794-a080-0564882042b4)

![image](https://github.com/user-attachments/assets/7bce0597-faf9-4a27-bb3a-bd46efc192bc)

![image](https://github.com/user-attachments/assets/36289c37-6a8d-45df-a084-24e23e1ed6c9)

Week 1 (lecture 2-Introduction to VLSI physical design)

![image](https://github.com/user-attachments/assets/711cd240-8413-475c-8023-6cbed03badfa)

![image](https://github.com/user-attachments/assets/6400d451-1935-4c34-85dd-3ba514f26754)

![image](https://github.com/user-attachments/assets/e902a973-25ed-411b-8cd3-cb6a67ab0ed7)

In Architectural design, we need to specify, which arcitecture(RISC, MIPS, etc) we are going to use. Also we need to specify, how the components are interconnected with each other and what kind of communication protocols we are going to use.

![image](https://github.com/user-attachments/assets/e89341d4-1a71-4c7c-b09d-923c67e9cac5)

![image](https://github.com/user-attachments/assets/862ba09b-2472-4847-b3b1-e2061a2c8783)

![image](https://github.com/user-attachments/assets/6a96b378-17a5-4192-8056-86e9fd7183db)

![image](https://github.com/user-attachments/assets/296ba7ed-c20d-418b-8620-4a8b97a24bb2)

Technology specific means, example: size of the transistor 6nm

![image](https://github.com/user-attachments/assets/f712fdae-4347-4f73-a2b9-9f65835a0009)

![image](https://github.com/user-attachments/assets/e4d68892-a2e7-49d6-ad2a-5235316fe6dd)

![image](https://github.com/user-attachments/assets/ddc64ab0-2f1c-4ff4-bf7c-a5f33c9bc40b)

![image](https://github.com/user-attachments/assets/60e7769c-951b-4907-a248-b55256b4a37a)

![image](https://github.com/user-attachments/assets/64a259b5-6a19-4401-a09e-27389e30c3ef)

![image](https://github.com/user-attachments/assets/0d1f4ec1-a7f7-479c-b719-ccf564b6140d)

![image](https://github.com/user-attachments/assets/85e2d2d1-762c-4f07-802d-4703cd3b28d1)

![image](https://github.com/user-attachments/assets/e77c5d12-5ba5-4efc-a10e-2063064a4c67)

Packaging is done to test the functionality of the chip.

![image](https://github.com/user-attachments/assets/b4f187d6-dfc9-4f0a-a79e-ef1d53deb3f7)

![image](https://github.com/user-attachments/assets/96740154-898a-4c17-abd9-ad80d7bd77ff)

![image](https://github.com/user-attachments/assets/25c25019-095a-41ec-8ebd-4504ae0db6a7)

![image](https://github.com/user-attachments/assets/29e0e0ba-3414-4ac1-aaf5-b58d5b9b7c95)

![image](https://github.com/user-attachments/assets/1fd62bb3-7cab-4587-98b8-54ab385b9f28)

The module shapes and arrangements are fixed during floor planning.

![image](https://github.com/user-attachments/assets/6c9765b4-fc90-4f0f-8224-3628dfa300e2)

![image](https://github.com/user-attachments/assets/8aec4c84-4366-41da-ba3e-92ea21f16440)

![image](https://github.com/user-attachments/assets/37e12525-2b23-4ead-841b-cce1f1301cd3)

![image](https://github.com/user-attachments/assets/e3d21480-ccca-4c07-af8d-eb2b542c70b0)

Timing closure is the most critical step. Here, the chip should maintain the timing that was specified initially by optimizing the placement and routing.

![image](https://github.com/user-attachments/assets/9c05ba92-5814-4f07-b57e-a2fd96efb47c)

![image](https://github.com/user-attachments/assets/e5b0f81a-3d56-4600-a82e-23a9f7b34483)

![image](https://github.com/user-attachments/assets/fcd12879-c987-4878-85c8-b3ff20c0b3d0)

![image](https://github.com/user-attachments/assets/d0995bfe-0244-44c9-8fc6-78f68622fb5b)

![image](https://github.com/user-attachments/assets/818f1169-22fb-4e2b-b794-f55ca973483f)

![image](https://github.com/user-attachments/assets/497dfdaa-544c-4306-bf7f-4a99515f4165)

![image](https://github.com/user-attachments/assets/fbf660ea-6813-466b-b1ed-7dfdee519909)

![image](https://github.com/user-attachments/assets/e363c35a-b442-4b38-96a4-f034ec178e8f)

![image](https://github.com/user-attachments/assets/7a0312e1-ec4a-41b3-b786-c143302cab28)

Device mismatch - the number of transistors are not same in the schematic and layout
property errors - different sized transistors

![image](https://github.com/user-attachments/assets/6e2fe45f-a30b-4243-b60f-1d3edc686988)

Missing device terminal - let us say that the substrate is not grounded, so this is a missing device terminal

![image](https://github.com/user-attachments/assets/7db8e857-cfd9-4e2c-b03a-04d494125ddf)

Schematic should be carefully designed. so, that it will be useful to check with the layout.

![image](https://github.com/user-attachments/assets/d96e35c6-dfc6-4304-8e9e-68b74ad1150d)

![image](https://github.com/user-attachments/assets/37bf5bc7-f161-4e8e-8d36-26113fce4cf1)

![image](https://github.com/user-attachments/assets/8c0b8a10-df7a-4731-a356-44c22ea3c964)

![image](https://github.com/user-attachments/assets/dcd5c2c4-fb15-4df4-8fb8-b0723da8d083)

![image](https://github.com/user-attachments/assets/b6d46beb-bcb3-4496-9fad-d4d6b8cbaae4)

![image](https://github.com/user-attachments/assets/72908d76-6f5d-44ce-bba3-a68b8ae1d073)

When the length of the metal is large, charge accumulation occurs and the gate of transistor will gets damaged. This can be avoided by using two methods as shown below.

![image](https://github.com/user-attachments/assets/ebde1908-81fc-482e-ac32-fb1a98e8a703)

![image](https://github.com/user-attachments/assets/944f3aea-a3ce-4227-addc-bbaccfb9d2d1)

lecture 3 - Complexity analysis for algorithms

![image](https://github.com/user-attachments/assets/b8e7d50f-1050-43a2-8278-fb7498e4b845)

![image](https://github.com/user-attachments/assets/e20998b9-41b6-4f07-bc50-bbffbd92fdd7)

Greedy algorithm - Finds the solution in less time. But, it is locally optimum and not globally optimum.
The Divide and Conquer and Dynamic programming algorithms are similar but the difference is, in Divide and Conquer algorithms, the divided subsets are independent and does not depend on other subsets and in Dynamic programming algorithms, the subsets will overlap on each other. 
Linear/ Integer programming algorithms - They are useful during routing.

![image](https://github.com/user-attachments/assets/1ee260bd-407f-437d-9bd2-6794bfd0aee9)

![image](https://github.com/user-attachments/assets/db80b640-fe2a-4898-b57a-d71539f0e003)

The below mentioned are important for the VLSI physical design implementations.

![image](https://github.com/user-attachments/assets/d22bc385-3925-41a4-af23-6a30666c67dd)

To understand the time and space complexity, we need to analyze the performance of the algorithms and select the algorithm which takes less time. Resource management - we need to choose the algorithm which takes less memory because, higher the memory, higher the space.

![image](https://github.com/user-attachments/assets/7fd9a322-6d45-45fc-b21c-42fe38293512)

We need to find a method where we can find the runtime of the algorithm which does not depend on all the below mentioned things.

![image](https://github.com/user-attachments/assets/cfe0c93d-395f-4a1c-aa40-71d95fd8a9cd)

![image](https://github.com/user-attachments/assets/37bdc7d8-8d80-4d69-9705-ef3e6e55f732)

![image](https://github.com/user-attachments/assets/9d9d7964-65d8-4edd-ac3b-8e23af94dbb3)

So, to find the complexity of the algorithm, we first remove the lower order terms and then we remove the co-efficient.

![image](https://github.com/user-attachments/assets/0dc94e0c-0d9b-4cef-8f43-9d0e997c4f27)

There is an analysis which does not depend on the type of the input, machine speed and the programming language. That is called Asymptotic analysis.

![image](https://github.com/user-attachments/assets/f1c6d0f7-7ed4-4e2d-bf2c-aed4d0a32f7e)

We have 3 different types of Asymptotic analysis. 

1

![image](https://github.com/user-attachments/assets/a4bff228-1041-4797-a0ba-9d357754e136)

![image](https://github.com/user-attachments/assets/a56f5cc7-5ef4-48fb-8286-f9991b2efd2f)

2

![image](https://github.com/user-attachments/assets/bee76051-e74f-4aba-80d9-3b61f743af46)

![image](https://github.com/user-attachments/assets/0dedf146-6e89-4f9a-85df-ec5c2e5176b0)

3

![image](https://github.com/user-attachments/assets/b807af14-c524-4400-a0dd-b59fa5b60753)

![image](https://github.com/user-attachments/assets/56297434-00f0-45fa-9c93-2b6cd9b873a9)

![image](https://github.com/user-attachments/assets/60bbe4b1-25b4-4a57-b1c4-1db4a039de49)

![image](https://github.com/user-attachments/assets/743b0de4-80a4-4397-b5e1-72a2469f25fa)

![image](https://github.com/user-attachments/assets/e7144420-87d4-40f7-85b8-23c9747e4cf8)

![image](https://github.com/user-attachments/assets/f2079fc5-5301-45ed-ac93-71ca91a78aa1)

Let us see how an algorithm can be implemented in two different time complexity.

![image](https://github.com/user-attachments/assets/608f357d-6aff-4f1e-a2dc-3ba342042c9b)

![image](https://github.com/user-attachments/assets/b9e89028-17cd-4862-b976-2f67083e82bd)

![image](https://github.com/user-attachments/assets/743fdb88-974d-4ad5-b82d-2533ea717d7b)

Here the we can't specifically mention the time delay in linear search. Because, the element can present in anywhere. But, the worst case time delay is the last element. So, we will say the complexity as the order of 'n'

![image](https://github.com/user-attachments/assets/9d93e28e-5b43-49b4-b05a-7ec90ae04e9f)

![image](https://github.com/user-attachments/assets/d8669dfa-15a9-4e7b-a5f0-0912e36f59aa)

